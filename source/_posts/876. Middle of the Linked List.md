---
layout:     post
title:      Middle of the Linked List
category:   LeetCode
tags: LinkedList
---

#### Middle of the Linked List

> Given a non-empty, singly linked list with head node head, return a middle node of linked list. If there are two middle nodes, return the second middle node.

两种思路，第二种实现仅仅需要五行。最近做题发现，很多时候解决一个问题，思路真的很重要。很多时候自己那些想法是需要被推翻和颠覆的。

第二种方法的思路是同时跑两个小狗，一个一次跑一步，另一个跑两步，关键在于设置停止的条件：当跑得快的小狗首先跑到结尾时有两种情况，一种是自己站在 `None` 处，另一种是它的下一步 `next` 指向了 `None` 。这两个条件的任何一个出现时，就去把跑得慢的小狗的位置返回去 -=≡Σ(((つ•̀ω•́)つ...

<!--more-->

#### 方法1

```python
#Definition for singly-linked list.
class ListNode:
    def __init__(self, x):
        self.val = x
        self.next = None

class Solution:
    def middleNode(self, head: ListNode) -> ListNode:
        i = 0
        l = head
        while head:
            head = head.next
            i += 1
        for j in range(int(i/2)):
            l = l.next
        return l
```



#### 方法2

```python
#Definition for singly-linked list.
class ListNode:
    def __init__(self, x):
        self.val = x
        self.next = None

class Solution:
    def middleNode(self, head: ListNode) -> ListNode:
        l = head
        while l and l.next:
            l = l.next.next
            head = head.next
        return head
       
```

Test

```python
s  = Solution
l1 = ListNode(1)
l1.next = ListNode(2)
l1 = l1.next
l1.next = ListNode(3)
l1 = l1.next
l1.next = ListNode(4)
l1 = l1.next
l1.next = ListNode(5)
L = s.middleNode(s,l1)
while L:
    print(L.val," -> ", end = "")
    L = L.next
print("None")
# 3 -> 4 -> 5
```